Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    DOT
    EMPTY
    EPS
    GTHAN
    LTHAN
    OR
    SQUOTES

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAMA ID SEMICOLON variables function bloque
Rule 2     variables -> VARS variables1
Rule 3     variables1 -> tipo COLON listaids
Rule 4     listaids -> ID listaids1
Rule 5     listaids1 -> COMA ID listaids1
Rule 6     listaids1 -> listaids2
Rule 7     listaids1 -> SEMICOLON
Rule 8     listaids2 -> LBRACKET INT RBRACKET listaids1
Rule 9     listaids2 -> LBRACKET INT RBRACKET SEMICOLON
Rule 10    listaids2 -> SEMICOLON
Rule 11    tipo -> INT
Rule 12    tipo -> FLOAT
Rule 13    tipo -> CHAR
Rule 14    function -> FUNCTION tiporetorno ID LPAREN variables1 RPAREN SEMICOLON variables bloque
Rule 15    bloque -> LCBRACKET estatuto bloque1
Rule 16    bloque -> LCBRACKET RCBRACKET
Rule 17    bloque1 -> RCBRACKET
Rule 18    bloque1 -> estatuto
Rule 19    estatuto -> asignacion
Rule 20    estatuto -> retornofuncion
Rule 21    estatuto -> lectura
Rule 22    estatuto -> escritura
Rule 23    estatuto -> decision
Rule 24    estatuto -> repeticion
Rule 25    tiporetorno -> INT
Rule 26    tiporetorno -> FLOAT
Rule 27    asignacion -> ID EQUALS expresion SEMICOLON
Rule 28    asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON
Rule 29    retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON
Rule 30    expresion -> expresion PLUS expresion
Rule 31    expresion -> expresion MINUS expresion
Rule 32    expresion -> expresion TIMES expresion
Rule 33    expresion -> expresion DIVIDE expresion
Rule 34    expresion -> LPAREN expresion RPAREN
Rule 35    expresion -> INT
Rule 36    expresion -> FLOAT
Rule 37    lectura -> READ LPAREN lectura1
Rule 38    lectura1 -> RPAREN SEMICOLON
Rule 39    lectura1 -> listaids lectura1
Rule 40    escritura -> WRITE LPAREN escritura1
Rule 41    escritura1 -> letrero escritura2
Rule 42    escritura1 -> expresion escritura2
Rule 43    escritura2 -> RPAREN SEMICOLON
Rule 44    escritura2 -> escritura1
Rule 45    letrero -> QUOTES letrero1
Rule 46    letrero1 -> CHAR QUOTES
Rule 47    letrero1 -> CHAR letrero1
Rule 48    repeticion -> condicional
Rule 49    repeticion -> nocondicional
Rule 50    decision -> IF LPAREN expresion RPAREN THEN bloque decision1
Rule 51    decision1 -> ELSE bloque
Rule 52    condicional -> WHILE LPAREN expresion RPAREN DO bloque
Rule 53    nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque

Terminals, with rules where they appear

AND                  : 
CHAR                 : 13 46 47
COLON                : 3
COMA                 : 5
DIVIDE               : 33
DO                   : 52 53
DOT                  : 
ELSE                 : 51
EMPTY                : 
EPS                  : 
EQUALS               : 27 28 53
FLOAT                : 12 26 36
FOR                  : 53
FUNCTION             : 14
GTHAN                : 
ID                   : 1 4 5 14 27 28 53
IF                   : 50
INT                  : 8 9 11 25 35
LBRACKET             : 8 9 28
LCBRACKET            : 15 16
LPAREN               : 14 29 34 37 40 50 52
LTHAN                : 
MINUS                : 31
OR                   : 
PLUS                 : 30
PROGRAMA             : 1
QUOTES               : 45 46
RBRACKET             : 8 9 28
RCBRACKET            : 16 17
READ                 : 37
RETURN               : 29
RPAREN               : 14 29 34 38 43 50 52
SEMICOLON            : 1 7 9 10 14 27 28 29 38 43
SQUOTES              : 
THEN                 : 50
TIMES                : 32
TO                   : 53
VARS                 : 2
WHILE                : 52
WRITE                : 40
error                : 

Nonterminals, with rules where they appear

asignacion           : 19
bloque               : 1 14 50 51 52 53
bloque1              : 15
condicional          : 48
decision             : 23
decision1            : 50
escritura            : 22
escritura1           : 40 44
escritura2           : 41 42
estatuto             : 15 18
expresion            : 27 28 28 29 30 30 31 31 32 32 33 33 34 42 50 52 53 53
function             : 1
lectura              : 21
lectura1             : 37 39
letrero              : 41
letrero1             : 45 47
listaids             : 3 39
listaids1            : 4 5 8
listaids2            : 6
nocondicional        : 49
programa             : 0
repeticion           : 24
retornofuncion       : 20
tipo                 : 3
tiporetorno          : 14
variables            : 1 14
variables1           : 2 14

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAMA ID SEMICOLON variables function bloque

    PROGRAMA        shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> PROGRAMA . ID SEMICOLON variables function bloque

    ID              shift and go to state 3


state 3

    (1) programa -> PROGRAMA ID . SEMICOLON variables function bloque

    SEMICOLON       shift and go to state 4


state 4

    (1) programa -> PROGRAMA ID SEMICOLON . variables function bloque
    (2) variables -> . VARS variables1

    VARS            shift and go to state 6

    variables                      shift and go to state 5

state 5

    (1) programa -> PROGRAMA ID SEMICOLON variables . function bloque
    (14) function -> . FUNCTION tiporetorno ID LPAREN variables1 RPAREN SEMICOLON variables bloque

    FUNCTION        shift and go to state 8

    function                       shift and go to state 7

state 6

    (2) variables -> VARS . variables1
    (3) variables1 -> . tipo COLON listaids
    (11) tipo -> . INT
    (12) tipo -> . FLOAT
    (13) tipo -> . CHAR

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13

    variables1                     shift and go to state 9
    tipo                           shift and go to state 10

state 7

    (1) programa -> PROGRAMA ID SEMICOLON variables function . bloque
    (15) bloque -> . LCBRACKET estatuto bloque1
    (16) bloque -> . LCBRACKET RCBRACKET

    LCBRACKET       shift and go to state 15

    bloque                         shift and go to state 14

state 8

    (14) function -> FUNCTION . tiporetorno ID LPAREN variables1 RPAREN SEMICOLON variables bloque
    (25) tiporetorno -> . INT
    (26) tiporetorno -> . FLOAT

    INT             shift and go to state 17
    FLOAT           shift and go to state 18

    tiporetorno                    shift and go to state 16

state 9

    (2) variables -> VARS variables1 .

    FUNCTION        reduce using rule 2 (variables -> VARS variables1 .)
    LCBRACKET       reduce using rule 2 (variables -> VARS variables1 .)


state 10

    (3) variables1 -> tipo . COLON listaids

    COLON           shift and go to state 19


state 11

    (11) tipo -> INT .

    COLON           reduce using rule 11 (tipo -> INT .)


state 12

    (12) tipo -> FLOAT .

    COLON           reduce using rule 12 (tipo -> FLOAT .)


state 13

    (13) tipo -> CHAR .

    COLON           reduce using rule 13 (tipo -> CHAR .)


state 14

    (1) programa -> PROGRAMA ID SEMICOLON variables function bloque .

    $end            reduce using rule 1 (programa -> PROGRAMA ID SEMICOLON variables function bloque .)


state 15

    (15) bloque -> LCBRACKET . estatuto bloque1
    (16) bloque -> LCBRACKET . RCBRACKET
    (19) estatuto -> . asignacion
    (20) estatuto -> . retornofuncion
    (21) estatuto -> . lectura
    (22) estatuto -> . escritura
    (23) estatuto -> . decision
    (24) estatuto -> . repeticion
    (27) asignacion -> . ID EQUALS expresion SEMICOLON
    (28) asignacion -> . ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON
    (29) retornofuncion -> . RETURN LPAREN expresion RPAREN SEMICOLON
    (37) lectura -> . READ LPAREN lectura1
    (40) escritura -> . WRITE LPAREN escritura1
    (50) decision -> . IF LPAREN expresion RPAREN THEN bloque decision1
    (48) repeticion -> . condicional
    (49) repeticion -> . nocondicional
    (52) condicional -> . WHILE LPAREN expresion RPAREN DO bloque
    (53) nocondicional -> . FOR ID EQUALS expresion TO expresion DO bloque

    RCBRACKET       shift and go to state 21
    ID              shift and go to state 28
    RETURN          shift and go to state 29
    READ            shift and go to state 30
    WRITE           shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 35
    FOR             shift and go to state 36

    estatuto                       shift and go to state 20
    asignacion                     shift and go to state 22
    retornofuncion                 shift and go to state 23
    lectura                        shift and go to state 24
    escritura                      shift and go to state 25
    decision                       shift and go to state 26
    repeticion                     shift and go to state 27
    condicional                    shift and go to state 33
    nocondicional                  shift and go to state 34

state 16

    (14) function -> FUNCTION tiporetorno . ID LPAREN variables1 RPAREN SEMICOLON variables bloque

    ID              shift and go to state 37


state 17

    (25) tiporetorno -> INT .

    ID              reduce using rule 25 (tiporetorno -> INT .)


state 18

    (26) tiporetorno -> FLOAT .

    ID              reduce using rule 26 (tiporetorno -> FLOAT .)


state 19

    (3) variables1 -> tipo COLON . listaids
    (4) listaids -> . ID listaids1

    ID              shift and go to state 39

    listaids                       shift and go to state 38

state 20

    (15) bloque -> LCBRACKET estatuto . bloque1
    (17) bloque1 -> . RCBRACKET
    (18) bloque1 -> . estatuto
    (19) estatuto -> . asignacion
    (20) estatuto -> . retornofuncion
    (21) estatuto -> . lectura
    (22) estatuto -> . escritura
    (23) estatuto -> . decision
    (24) estatuto -> . repeticion
    (27) asignacion -> . ID EQUALS expresion SEMICOLON
    (28) asignacion -> . ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON
    (29) retornofuncion -> . RETURN LPAREN expresion RPAREN SEMICOLON
    (37) lectura -> . READ LPAREN lectura1
    (40) escritura -> . WRITE LPAREN escritura1
    (50) decision -> . IF LPAREN expresion RPAREN THEN bloque decision1
    (48) repeticion -> . condicional
    (49) repeticion -> . nocondicional
    (52) condicional -> . WHILE LPAREN expresion RPAREN DO bloque
    (53) nocondicional -> . FOR ID EQUALS expresion TO expresion DO bloque

    RCBRACKET       shift and go to state 42
    ID              shift and go to state 28
    RETURN          shift and go to state 29
    READ            shift and go to state 30
    WRITE           shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 35
    FOR             shift and go to state 36

    estatuto                       shift and go to state 40
    bloque1                        shift and go to state 41
    asignacion                     shift and go to state 22
    retornofuncion                 shift and go to state 23
    lectura                        shift and go to state 24
    escritura                      shift and go to state 25
    decision                       shift and go to state 26
    repeticion                     shift and go to state 27
    condicional                    shift and go to state 33
    nocondicional                  shift and go to state 34

state 21

    (16) bloque -> LCBRACKET RCBRACKET .

    $end            reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    ELSE            reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    RCBRACKET       reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    ID              reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    RETURN          reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    READ            reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    WRITE           reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    IF              reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    WHILE           reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    FOR             reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)
    LCBRACKET       reduce using rule 16 (bloque -> LCBRACKET RCBRACKET .)


state 22

    (19) estatuto -> asignacion .

    RCBRACKET       reduce using rule 19 (estatuto -> asignacion .)
    ID              reduce using rule 19 (estatuto -> asignacion .)
    RETURN          reduce using rule 19 (estatuto -> asignacion .)
    READ            reduce using rule 19 (estatuto -> asignacion .)
    WRITE           reduce using rule 19 (estatuto -> asignacion .)
    IF              reduce using rule 19 (estatuto -> asignacion .)
    WHILE           reduce using rule 19 (estatuto -> asignacion .)
    FOR             reduce using rule 19 (estatuto -> asignacion .)
    $end            reduce using rule 19 (estatuto -> asignacion .)
    ELSE            reduce using rule 19 (estatuto -> asignacion .)
    LCBRACKET       reduce using rule 19 (estatuto -> asignacion .)


state 23

    (20) estatuto -> retornofuncion .

    RCBRACKET       reduce using rule 20 (estatuto -> retornofuncion .)
    ID              reduce using rule 20 (estatuto -> retornofuncion .)
    RETURN          reduce using rule 20 (estatuto -> retornofuncion .)
    READ            reduce using rule 20 (estatuto -> retornofuncion .)
    WRITE           reduce using rule 20 (estatuto -> retornofuncion .)
    IF              reduce using rule 20 (estatuto -> retornofuncion .)
    WHILE           reduce using rule 20 (estatuto -> retornofuncion .)
    FOR             reduce using rule 20 (estatuto -> retornofuncion .)
    $end            reduce using rule 20 (estatuto -> retornofuncion .)
    ELSE            reduce using rule 20 (estatuto -> retornofuncion .)
    LCBRACKET       reduce using rule 20 (estatuto -> retornofuncion .)


state 24

    (21) estatuto -> lectura .

    RCBRACKET       reduce using rule 21 (estatuto -> lectura .)
    ID              reduce using rule 21 (estatuto -> lectura .)
    RETURN          reduce using rule 21 (estatuto -> lectura .)
    READ            reduce using rule 21 (estatuto -> lectura .)
    WRITE           reduce using rule 21 (estatuto -> lectura .)
    IF              reduce using rule 21 (estatuto -> lectura .)
    WHILE           reduce using rule 21 (estatuto -> lectura .)
    FOR             reduce using rule 21 (estatuto -> lectura .)
    $end            reduce using rule 21 (estatuto -> lectura .)
    ELSE            reduce using rule 21 (estatuto -> lectura .)
    LCBRACKET       reduce using rule 21 (estatuto -> lectura .)


state 25

    (22) estatuto -> escritura .

    RCBRACKET       reduce using rule 22 (estatuto -> escritura .)
    ID              reduce using rule 22 (estatuto -> escritura .)
    RETURN          reduce using rule 22 (estatuto -> escritura .)
    READ            reduce using rule 22 (estatuto -> escritura .)
    WRITE           reduce using rule 22 (estatuto -> escritura .)
    IF              reduce using rule 22 (estatuto -> escritura .)
    WHILE           reduce using rule 22 (estatuto -> escritura .)
    FOR             reduce using rule 22 (estatuto -> escritura .)
    $end            reduce using rule 22 (estatuto -> escritura .)
    ELSE            reduce using rule 22 (estatuto -> escritura .)
    LCBRACKET       reduce using rule 22 (estatuto -> escritura .)


state 26

    (23) estatuto -> decision .

    RCBRACKET       reduce using rule 23 (estatuto -> decision .)
    ID              reduce using rule 23 (estatuto -> decision .)
    RETURN          reduce using rule 23 (estatuto -> decision .)
    READ            reduce using rule 23 (estatuto -> decision .)
    WRITE           reduce using rule 23 (estatuto -> decision .)
    IF              reduce using rule 23 (estatuto -> decision .)
    WHILE           reduce using rule 23 (estatuto -> decision .)
    FOR             reduce using rule 23 (estatuto -> decision .)
    $end            reduce using rule 23 (estatuto -> decision .)
    ELSE            reduce using rule 23 (estatuto -> decision .)
    LCBRACKET       reduce using rule 23 (estatuto -> decision .)


state 27

    (24) estatuto -> repeticion .

    RCBRACKET       reduce using rule 24 (estatuto -> repeticion .)
    ID              reduce using rule 24 (estatuto -> repeticion .)
    RETURN          reduce using rule 24 (estatuto -> repeticion .)
    READ            reduce using rule 24 (estatuto -> repeticion .)
    WRITE           reduce using rule 24 (estatuto -> repeticion .)
    IF              reduce using rule 24 (estatuto -> repeticion .)
    WHILE           reduce using rule 24 (estatuto -> repeticion .)
    FOR             reduce using rule 24 (estatuto -> repeticion .)
    $end            reduce using rule 24 (estatuto -> repeticion .)
    ELSE            reduce using rule 24 (estatuto -> repeticion .)
    LCBRACKET       reduce using rule 24 (estatuto -> repeticion .)


state 28

    (27) asignacion -> ID . EQUALS expresion SEMICOLON
    (28) asignacion -> ID . LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON

    EQUALS          shift and go to state 43
    LBRACKET        shift and go to state 44


state 29

    (29) retornofuncion -> RETURN . LPAREN expresion RPAREN SEMICOLON

    LPAREN          shift and go to state 45


state 30

    (37) lectura -> READ . LPAREN lectura1

    LPAREN          shift and go to state 46


state 31

    (40) escritura -> WRITE . LPAREN escritura1

    LPAREN          shift and go to state 47


state 32

    (50) decision -> IF . LPAREN expresion RPAREN THEN bloque decision1

    LPAREN          shift and go to state 48


state 33

    (48) repeticion -> condicional .

    RCBRACKET       reduce using rule 48 (repeticion -> condicional .)
    ID              reduce using rule 48 (repeticion -> condicional .)
    RETURN          reduce using rule 48 (repeticion -> condicional .)
    READ            reduce using rule 48 (repeticion -> condicional .)
    WRITE           reduce using rule 48 (repeticion -> condicional .)
    IF              reduce using rule 48 (repeticion -> condicional .)
    WHILE           reduce using rule 48 (repeticion -> condicional .)
    FOR             reduce using rule 48 (repeticion -> condicional .)
    $end            reduce using rule 48 (repeticion -> condicional .)
    ELSE            reduce using rule 48 (repeticion -> condicional .)
    LCBRACKET       reduce using rule 48 (repeticion -> condicional .)


state 34

    (49) repeticion -> nocondicional .

    RCBRACKET       reduce using rule 49 (repeticion -> nocondicional .)
    ID              reduce using rule 49 (repeticion -> nocondicional .)
    RETURN          reduce using rule 49 (repeticion -> nocondicional .)
    READ            reduce using rule 49 (repeticion -> nocondicional .)
    WRITE           reduce using rule 49 (repeticion -> nocondicional .)
    IF              reduce using rule 49 (repeticion -> nocondicional .)
    WHILE           reduce using rule 49 (repeticion -> nocondicional .)
    FOR             reduce using rule 49 (repeticion -> nocondicional .)
    $end            reduce using rule 49 (repeticion -> nocondicional .)
    ELSE            reduce using rule 49 (repeticion -> nocondicional .)
    LCBRACKET       reduce using rule 49 (repeticion -> nocondicional .)


state 35

    (52) condicional -> WHILE . LPAREN expresion RPAREN DO bloque

    LPAREN          shift and go to state 49


state 36

    (53) nocondicional -> FOR . ID EQUALS expresion TO expresion DO bloque

    ID              shift and go to state 50


state 37

    (14) function -> FUNCTION tiporetorno ID . LPAREN variables1 RPAREN SEMICOLON variables bloque

    LPAREN          shift and go to state 51


state 38

    (3) variables1 -> tipo COLON listaids .

    FUNCTION        reduce using rule 3 (variables1 -> tipo COLON listaids .)
    LCBRACKET       reduce using rule 3 (variables1 -> tipo COLON listaids .)
    RPAREN          reduce using rule 3 (variables1 -> tipo COLON listaids .)


state 39

    (4) listaids -> ID . listaids1
    (5) listaids1 -> . COMA ID listaids1
    (6) listaids1 -> . listaids2
    (7) listaids1 -> . SEMICOLON
    (8) listaids2 -> . LBRACKET INT RBRACKET listaids1
    (9) listaids2 -> . LBRACKET INT RBRACKET SEMICOLON
    (10) listaids2 -> . SEMICOLON

    COMA            shift and go to state 53
    SEMICOLON       shift and go to state 55
    LBRACKET        shift and go to state 56

    listaids1                      shift and go to state 52
    listaids2                      shift and go to state 54

state 40

    (18) bloque1 -> estatuto .

    $end            reduce using rule 18 (bloque1 -> estatuto .)
    ELSE            reduce using rule 18 (bloque1 -> estatuto .)
    RCBRACKET       reduce using rule 18 (bloque1 -> estatuto .)
    ID              reduce using rule 18 (bloque1 -> estatuto .)
    RETURN          reduce using rule 18 (bloque1 -> estatuto .)
    READ            reduce using rule 18 (bloque1 -> estatuto .)
    WRITE           reduce using rule 18 (bloque1 -> estatuto .)
    IF              reduce using rule 18 (bloque1 -> estatuto .)
    WHILE           reduce using rule 18 (bloque1 -> estatuto .)
    FOR             reduce using rule 18 (bloque1 -> estatuto .)
    LCBRACKET       reduce using rule 18 (bloque1 -> estatuto .)


state 41

    (15) bloque -> LCBRACKET estatuto bloque1 .

    $end            reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    ELSE            reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    RCBRACKET       reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    ID              reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    RETURN          reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    READ            reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    WRITE           reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    IF              reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    WHILE           reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    FOR             reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)
    LCBRACKET       reduce using rule 15 (bloque -> LCBRACKET estatuto bloque1 .)


state 42

    (17) bloque1 -> RCBRACKET .

    $end            reduce using rule 17 (bloque1 -> RCBRACKET .)
    ELSE            reduce using rule 17 (bloque1 -> RCBRACKET .)
    RCBRACKET       reduce using rule 17 (bloque1 -> RCBRACKET .)
    ID              reduce using rule 17 (bloque1 -> RCBRACKET .)
    RETURN          reduce using rule 17 (bloque1 -> RCBRACKET .)
    READ            reduce using rule 17 (bloque1 -> RCBRACKET .)
    WRITE           reduce using rule 17 (bloque1 -> RCBRACKET .)
    IF              reduce using rule 17 (bloque1 -> RCBRACKET .)
    WHILE           reduce using rule 17 (bloque1 -> RCBRACKET .)
    FOR             reduce using rule 17 (bloque1 -> RCBRACKET .)
    LCBRACKET       reduce using rule 17 (bloque1 -> RCBRACKET .)


state 43

    (27) asignacion -> ID EQUALS . expresion SEMICOLON
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 57

state 44

    (28) asignacion -> ID LBRACKET . expresion RBRACKET EQUALS expresion SEMICOLON
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 61

state 45

    (29) retornofuncion -> RETURN LPAREN . expresion RPAREN SEMICOLON
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 62

state 46

    (37) lectura -> READ LPAREN . lectura1
    (38) lectura1 -> . RPAREN SEMICOLON
    (39) lectura1 -> . listaids lectura1
    (4) listaids -> . ID listaids1

    RPAREN          shift and go to state 64
    ID              shift and go to state 39

    lectura1                       shift and go to state 63
    listaids                       shift and go to state 65

state 47

    (40) escritura -> WRITE LPAREN . escritura1
    (41) escritura1 -> . letrero escritura2
    (42) escritura1 -> . expresion escritura2
    (45) letrero -> . QUOTES letrero1
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    QUOTES          shift and go to state 69
    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    escritura1                     shift and go to state 66
    letrero                        shift and go to state 67
    expresion                      shift and go to state 68

state 48

    (50) decision -> IF LPAREN . expresion RPAREN THEN bloque decision1
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 70

state 49

    (52) condicional -> WHILE LPAREN . expresion RPAREN DO bloque
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 71

state 50

    (53) nocondicional -> FOR ID . EQUALS expresion TO expresion DO bloque

    EQUALS          shift and go to state 72


state 51

    (14) function -> FUNCTION tiporetorno ID LPAREN . variables1 RPAREN SEMICOLON variables bloque
    (3) variables1 -> . tipo COLON listaids
    (11) tipo -> . INT
    (12) tipo -> . FLOAT
    (13) tipo -> . CHAR

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13

    variables1                     shift and go to state 73
    tipo                           shift and go to state 10

state 52

    (4) listaids -> ID listaids1 .

    FUNCTION        reduce using rule 4 (listaids -> ID listaids1 .)
    LCBRACKET       reduce using rule 4 (listaids -> ID listaids1 .)
    RPAREN          reduce using rule 4 (listaids -> ID listaids1 .)
    ID              reduce using rule 4 (listaids -> ID listaids1 .)


state 53

    (5) listaids1 -> COMA . ID listaids1

    ID              shift and go to state 74


state 54

    (6) listaids1 -> listaids2 .

    FUNCTION        reduce using rule 6 (listaids1 -> listaids2 .)
    LCBRACKET       reduce using rule 6 (listaids1 -> listaids2 .)
    RPAREN          reduce using rule 6 (listaids1 -> listaids2 .)
    ID              reduce using rule 6 (listaids1 -> listaids2 .)


state 55

    (7) listaids1 -> SEMICOLON .
    (10) listaids2 -> SEMICOLON .

  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for LCBRACKET resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for RPAREN resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 7 (listaids1 -> SEMICOLON .)
    FUNCTION        reduce using rule 7 (listaids1 -> SEMICOLON .)
    LCBRACKET       reduce using rule 7 (listaids1 -> SEMICOLON .)
    RPAREN          reduce using rule 7 (listaids1 -> SEMICOLON .)
    ID              reduce using rule 7 (listaids1 -> SEMICOLON .)

  ! FUNCTION        [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]
  ! LCBRACKET       [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]
  ! RPAREN          [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]
  ! ID              [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]


state 56

    (8) listaids2 -> LBRACKET . INT RBRACKET listaids1
    (9) listaids2 -> LBRACKET . INT RBRACKET SEMICOLON

    INT             shift and go to state 75


state 57

    (27) asignacion -> ID EQUALS expresion . SEMICOLON
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    SEMICOLON       shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 58

    (34) expresion -> LPAREN . expresion RPAREN
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 81

state 59

    (35) expresion -> INT .

    SEMICOLON       reduce using rule 35 (expresion -> INT .)
    PLUS            reduce using rule 35 (expresion -> INT .)
    MINUS           reduce using rule 35 (expresion -> INT .)
    TIMES           reduce using rule 35 (expresion -> INT .)
    DIVIDE          reduce using rule 35 (expresion -> INT .)
    RBRACKET        reduce using rule 35 (expresion -> INT .)
    RPAREN          reduce using rule 35 (expresion -> INT .)
    QUOTES          reduce using rule 35 (expresion -> INT .)
    LPAREN          reduce using rule 35 (expresion -> INT .)
    INT             reduce using rule 35 (expresion -> INT .)
    FLOAT           reduce using rule 35 (expresion -> INT .)
    TO              reduce using rule 35 (expresion -> INT .)
    DO              reduce using rule 35 (expresion -> INT .)


state 60

    (36) expresion -> FLOAT .

    SEMICOLON       reduce using rule 36 (expresion -> FLOAT .)
    PLUS            reduce using rule 36 (expresion -> FLOAT .)
    MINUS           reduce using rule 36 (expresion -> FLOAT .)
    TIMES           reduce using rule 36 (expresion -> FLOAT .)
    DIVIDE          reduce using rule 36 (expresion -> FLOAT .)
    RBRACKET        reduce using rule 36 (expresion -> FLOAT .)
    RPAREN          reduce using rule 36 (expresion -> FLOAT .)
    QUOTES          reduce using rule 36 (expresion -> FLOAT .)
    LPAREN          reduce using rule 36 (expresion -> FLOAT .)
    INT             reduce using rule 36 (expresion -> FLOAT .)
    FLOAT           reduce using rule 36 (expresion -> FLOAT .)
    TO              reduce using rule 36 (expresion -> FLOAT .)
    DO              reduce using rule 36 (expresion -> FLOAT .)


state 61

    (28) asignacion -> ID LBRACKET expresion . RBRACKET EQUALS expresion SEMICOLON
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    RBRACKET        shift and go to state 82
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 62

    (29) retornofuncion -> RETURN LPAREN expresion . RPAREN SEMICOLON
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    RPAREN          shift and go to state 83
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 63

    (37) lectura -> READ LPAREN lectura1 .

    RCBRACKET       reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    ID              reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    RETURN          reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    READ            reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    WRITE           reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    IF              reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    WHILE           reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    FOR             reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    $end            reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    ELSE            reduce using rule 37 (lectura -> READ LPAREN lectura1 .)
    LCBRACKET       reduce using rule 37 (lectura -> READ LPAREN lectura1 .)


state 64

    (38) lectura1 -> RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 84


state 65

    (39) lectura1 -> listaids . lectura1
    (38) lectura1 -> . RPAREN SEMICOLON
    (39) lectura1 -> . listaids lectura1
    (4) listaids -> . ID listaids1

    RPAREN          shift and go to state 64
    ID              shift and go to state 39

    listaids                       shift and go to state 65
    lectura1                       shift and go to state 85

state 66

    (40) escritura -> WRITE LPAREN escritura1 .

    RCBRACKET       reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    ID              reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    RETURN          reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    READ            reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    WRITE           reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    IF              reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    WHILE           reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    FOR             reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    $end            reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    ELSE            reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)
    LCBRACKET       reduce using rule 40 (escritura -> WRITE LPAREN escritura1 .)


state 67

    (41) escritura1 -> letrero . escritura2
    (43) escritura2 -> . RPAREN SEMICOLON
    (44) escritura2 -> . escritura1
    (41) escritura1 -> . letrero escritura2
    (42) escritura1 -> . expresion escritura2
    (45) letrero -> . QUOTES letrero1
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    RPAREN          shift and go to state 87
    QUOTES          shift and go to state 69
    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    letrero                        shift and go to state 67
    escritura2                     shift and go to state 86
    escritura1                     shift and go to state 88
    expresion                      shift and go to state 68

state 68

    (42) escritura1 -> expresion . escritura2
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion
    (43) escritura2 -> . RPAREN SEMICOLON
    (44) escritura2 -> . escritura1
    (41) escritura1 -> . letrero escritura2
    (42) escritura1 -> . expresion escritura2
    (45) letrero -> . QUOTES letrero1
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    RPAREN          shift and go to state 87
    QUOTES          shift and go to state 69
    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 68
    escritura2                     shift and go to state 89
    escritura1                     shift and go to state 88
    letrero                        shift and go to state 67

state 69

    (45) letrero -> QUOTES . letrero1
    (46) letrero1 -> . CHAR QUOTES
    (47) letrero1 -> . CHAR letrero1

    CHAR            shift and go to state 91

    letrero1                       shift and go to state 90

state 70

    (50) decision -> IF LPAREN expresion . RPAREN THEN bloque decision1
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    RPAREN          shift and go to state 92
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 71

    (52) condicional -> WHILE LPAREN expresion . RPAREN DO bloque
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    RPAREN          shift and go to state 93
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 72

    (53) nocondicional -> FOR ID EQUALS . expresion TO expresion DO bloque
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 94

state 73

    (14) function -> FUNCTION tiporetorno ID LPAREN variables1 . RPAREN SEMICOLON variables bloque

    RPAREN          shift and go to state 95


state 74

    (5) listaids1 -> COMA ID . listaids1
    (5) listaids1 -> . COMA ID listaids1
    (6) listaids1 -> . listaids2
    (7) listaids1 -> . SEMICOLON
    (8) listaids2 -> . LBRACKET INT RBRACKET listaids1
    (9) listaids2 -> . LBRACKET INT RBRACKET SEMICOLON
    (10) listaids2 -> . SEMICOLON

    COMA            shift and go to state 53
    SEMICOLON       shift and go to state 55
    LBRACKET        shift and go to state 56

    listaids1                      shift and go to state 96
    listaids2                      shift and go to state 54

state 75

    (8) listaids2 -> LBRACKET INT . RBRACKET listaids1
    (9) listaids2 -> LBRACKET INT . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 97


state 76

    (27) asignacion -> ID EQUALS expresion SEMICOLON .

    RCBRACKET       reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    ID              reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    RETURN          reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    READ            reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    WRITE           reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    IF              reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    WHILE           reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    FOR             reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    $end            reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    ELSE            reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)
    LCBRACKET       reduce using rule 27 (asignacion -> ID EQUALS expresion SEMICOLON .)


state 77

    (30) expresion -> expresion PLUS . expresion
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 98

state 78

    (31) expresion -> expresion MINUS . expresion
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 99

state 79

    (32) expresion -> expresion TIMES . expresion
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 100

state 80

    (33) expresion -> expresion DIVIDE . expresion
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 101

state 81

    (34) expresion -> LPAREN expresion . RPAREN
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    RPAREN          shift and go to state 102
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 82

    (28) asignacion -> ID LBRACKET expresion RBRACKET . EQUALS expresion SEMICOLON

    EQUALS          shift and go to state 103


state 83

    (29) retornofuncion -> RETURN LPAREN expresion RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 104


state 84

    (38) lectura1 -> RPAREN SEMICOLON .

    RCBRACKET       reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    ID              reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    READ            reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    WRITE           reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    IF              reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    FOR             reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    $end            reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    ELSE            reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)
    LCBRACKET       reduce using rule 38 (lectura1 -> RPAREN SEMICOLON .)


state 85

    (39) lectura1 -> listaids lectura1 .

    RCBRACKET       reduce using rule 39 (lectura1 -> listaids lectura1 .)
    ID              reduce using rule 39 (lectura1 -> listaids lectura1 .)
    RETURN          reduce using rule 39 (lectura1 -> listaids lectura1 .)
    READ            reduce using rule 39 (lectura1 -> listaids lectura1 .)
    WRITE           reduce using rule 39 (lectura1 -> listaids lectura1 .)
    IF              reduce using rule 39 (lectura1 -> listaids lectura1 .)
    WHILE           reduce using rule 39 (lectura1 -> listaids lectura1 .)
    FOR             reduce using rule 39 (lectura1 -> listaids lectura1 .)
    $end            reduce using rule 39 (lectura1 -> listaids lectura1 .)
    ELSE            reduce using rule 39 (lectura1 -> listaids lectura1 .)
    LCBRACKET       reduce using rule 39 (lectura1 -> listaids lectura1 .)


state 86

    (41) escritura1 -> letrero escritura2 .

    RCBRACKET       reduce using rule 41 (escritura1 -> letrero escritura2 .)
    ID              reduce using rule 41 (escritura1 -> letrero escritura2 .)
    RETURN          reduce using rule 41 (escritura1 -> letrero escritura2 .)
    READ            reduce using rule 41 (escritura1 -> letrero escritura2 .)
    WRITE           reduce using rule 41 (escritura1 -> letrero escritura2 .)
    IF              reduce using rule 41 (escritura1 -> letrero escritura2 .)
    WHILE           reduce using rule 41 (escritura1 -> letrero escritura2 .)
    FOR             reduce using rule 41 (escritura1 -> letrero escritura2 .)
    $end            reduce using rule 41 (escritura1 -> letrero escritura2 .)
    ELSE            reduce using rule 41 (escritura1 -> letrero escritura2 .)
    LCBRACKET       reduce using rule 41 (escritura1 -> letrero escritura2 .)


state 87

    (43) escritura2 -> RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 105


state 88

    (44) escritura2 -> escritura1 .

    RCBRACKET       reduce using rule 44 (escritura2 -> escritura1 .)
    ID              reduce using rule 44 (escritura2 -> escritura1 .)
    RETURN          reduce using rule 44 (escritura2 -> escritura1 .)
    READ            reduce using rule 44 (escritura2 -> escritura1 .)
    WRITE           reduce using rule 44 (escritura2 -> escritura1 .)
    IF              reduce using rule 44 (escritura2 -> escritura1 .)
    WHILE           reduce using rule 44 (escritura2 -> escritura1 .)
    FOR             reduce using rule 44 (escritura2 -> escritura1 .)
    $end            reduce using rule 44 (escritura2 -> escritura1 .)
    ELSE            reduce using rule 44 (escritura2 -> escritura1 .)
    LCBRACKET       reduce using rule 44 (escritura2 -> escritura1 .)


state 89

    (42) escritura1 -> expresion escritura2 .

    RCBRACKET       reduce using rule 42 (escritura1 -> expresion escritura2 .)
    ID              reduce using rule 42 (escritura1 -> expresion escritura2 .)
    RETURN          reduce using rule 42 (escritura1 -> expresion escritura2 .)
    READ            reduce using rule 42 (escritura1 -> expresion escritura2 .)
    WRITE           reduce using rule 42 (escritura1 -> expresion escritura2 .)
    IF              reduce using rule 42 (escritura1 -> expresion escritura2 .)
    WHILE           reduce using rule 42 (escritura1 -> expresion escritura2 .)
    FOR             reduce using rule 42 (escritura1 -> expresion escritura2 .)
    $end            reduce using rule 42 (escritura1 -> expresion escritura2 .)
    ELSE            reduce using rule 42 (escritura1 -> expresion escritura2 .)
    LCBRACKET       reduce using rule 42 (escritura1 -> expresion escritura2 .)


state 90

    (45) letrero -> QUOTES letrero1 .

    RPAREN          reduce using rule 45 (letrero -> QUOTES letrero1 .)
    QUOTES          reduce using rule 45 (letrero -> QUOTES letrero1 .)
    LPAREN          reduce using rule 45 (letrero -> QUOTES letrero1 .)
    INT             reduce using rule 45 (letrero -> QUOTES letrero1 .)
    FLOAT           reduce using rule 45 (letrero -> QUOTES letrero1 .)


state 91

    (46) letrero1 -> CHAR . QUOTES
    (47) letrero1 -> CHAR . letrero1
    (46) letrero1 -> . CHAR QUOTES
    (47) letrero1 -> . CHAR letrero1

    QUOTES          shift and go to state 106
    CHAR            shift and go to state 91

    letrero1                       shift and go to state 107

state 92

    (50) decision -> IF LPAREN expresion RPAREN . THEN bloque decision1

    THEN            shift and go to state 108


state 93

    (52) condicional -> WHILE LPAREN expresion RPAREN . DO bloque

    DO              shift and go to state 109


state 94

    (53) nocondicional -> FOR ID EQUALS expresion . TO expresion DO bloque
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    TO              shift and go to state 110
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 95

    (14) function -> FUNCTION tiporetorno ID LPAREN variables1 RPAREN . SEMICOLON variables bloque

    SEMICOLON       shift and go to state 111


state 96

    (5) listaids1 -> COMA ID listaids1 .

    FUNCTION        reduce using rule 5 (listaids1 -> COMA ID listaids1 .)
    LCBRACKET       reduce using rule 5 (listaids1 -> COMA ID listaids1 .)
    RPAREN          reduce using rule 5 (listaids1 -> COMA ID listaids1 .)
    ID              reduce using rule 5 (listaids1 -> COMA ID listaids1 .)


state 97

    (8) listaids2 -> LBRACKET INT RBRACKET . listaids1
    (9) listaids2 -> LBRACKET INT RBRACKET . SEMICOLON
    (5) listaids1 -> . COMA ID listaids1
    (6) listaids1 -> . listaids2
    (7) listaids1 -> . SEMICOLON
    (8) listaids2 -> . LBRACKET INT RBRACKET listaids1
    (9) listaids2 -> . LBRACKET INT RBRACKET SEMICOLON
    (10) listaids2 -> . SEMICOLON

    SEMICOLON       shift and go to state 113
    COMA            shift and go to state 53
    LBRACKET        shift and go to state 56

    listaids1                      shift and go to state 112
    listaids2                      shift and go to state 54

state 98

    (30) expresion -> expresion PLUS expresion .
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    SEMICOLON       reduce using rule 30 (expresion -> expresion PLUS expresion .)
    PLUS            reduce using rule 30 (expresion -> expresion PLUS expresion .)
    MINUS           reduce using rule 30 (expresion -> expresion PLUS expresion .)
    RBRACKET        reduce using rule 30 (expresion -> expresion PLUS expresion .)
    RPAREN          reduce using rule 30 (expresion -> expresion PLUS expresion .)
    QUOTES          reduce using rule 30 (expresion -> expresion PLUS expresion .)
    LPAREN          reduce using rule 30 (expresion -> expresion PLUS expresion .)
    INT             reduce using rule 30 (expresion -> expresion PLUS expresion .)
    FLOAT           reduce using rule 30 (expresion -> expresion PLUS expresion .)
    TO              reduce using rule 30 (expresion -> expresion PLUS expresion .)
    DO              reduce using rule 30 (expresion -> expresion PLUS expresion .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80

  ! TIMES           [ reduce using rule 30 (expresion -> expresion PLUS expresion .) ]
  ! DIVIDE          [ reduce using rule 30 (expresion -> expresion PLUS expresion .) ]
  ! PLUS            [ shift and go to state 77 ]
  ! MINUS           [ shift and go to state 78 ]


state 99

    (31) expresion -> expresion MINUS expresion .
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    SEMICOLON       reduce using rule 31 (expresion -> expresion MINUS expresion .)
    PLUS            reduce using rule 31 (expresion -> expresion MINUS expresion .)
    MINUS           reduce using rule 31 (expresion -> expresion MINUS expresion .)
    RBRACKET        reduce using rule 31 (expresion -> expresion MINUS expresion .)
    RPAREN          reduce using rule 31 (expresion -> expresion MINUS expresion .)
    QUOTES          reduce using rule 31 (expresion -> expresion MINUS expresion .)
    LPAREN          reduce using rule 31 (expresion -> expresion MINUS expresion .)
    INT             reduce using rule 31 (expresion -> expresion MINUS expresion .)
    FLOAT           reduce using rule 31 (expresion -> expresion MINUS expresion .)
    TO              reduce using rule 31 (expresion -> expresion MINUS expresion .)
    DO              reduce using rule 31 (expresion -> expresion MINUS expresion .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80

  ! TIMES           [ reduce using rule 31 (expresion -> expresion MINUS expresion .) ]
  ! DIVIDE          [ reduce using rule 31 (expresion -> expresion MINUS expresion .) ]
  ! PLUS            [ shift and go to state 77 ]
  ! MINUS           [ shift and go to state 78 ]


state 100

    (32) expresion -> expresion TIMES expresion .
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    SEMICOLON       reduce using rule 32 (expresion -> expresion TIMES expresion .)
    PLUS            reduce using rule 32 (expresion -> expresion TIMES expresion .)
    MINUS           reduce using rule 32 (expresion -> expresion TIMES expresion .)
    TIMES           reduce using rule 32 (expresion -> expresion TIMES expresion .)
    DIVIDE          reduce using rule 32 (expresion -> expresion TIMES expresion .)
    RBRACKET        reduce using rule 32 (expresion -> expresion TIMES expresion .)
    RPAREN          reduce using rule 32 (expresion -> expresion TIMES expresion .)
    QUOTES          reduce using rule 32 (expresion -> expresion TIMES expresion .)
    LPAREN          reduce using rule 32 (expresion -> expresion TIMES expresion .)
    INT             reduce using rule 32 (expresion -> expresion TIMES expresion .)
    FLOAT           reduce using rule 32 (expresion -> expresion TIMES expresion .)
    TO              reduce using rule 32 (expresion -> expresion TIMES expresion .)
    DO              reduce using rule 32 (expresion -> expresion TIMES expresion .)

  ! PLUS            [ shift and go to state 77 ]
  ! MINUS           [ shift and go to state 78 ]
  ! TIMES           [ shift and go to state 79 ]
  ! DIVIDE          [ shift and go to state 80 ]


state 101

    (33) expresion -> expresion DIVIDE expresion .
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    SEMICOLON       reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    PLUS            reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    MINUS           reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    TIMES           reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    DIVIDE          reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    RBRACKET        reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    RPAREN          reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    QUOTES          reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    LPAREN          reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    INT             reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    FLOAT           reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    TO              reduce using rule 33 (expresion -> expresion DIVIDE expresion .)
    DO              reduce using rule 33 (expresion -> expresion DIVIDE expresion .)

  ! PLUS            [ shift and go to state 77 ]
  ! MINUS           [ shift and go to state 78 ]
  ! TIMES           [ shift and go to state 79 ]
  ! DIVIDE          [ shift and go to state 80 ]


state 102

    (34) expresion -> LPAREN expresion RPAREN .

    SEMICOLON       reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    TIMES           reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    QUOTES          reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    LPAREN          reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    INT             reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    FLOAT           reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    TO              reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)
    DO              reduce using rule 34 (expresion -> LPAREN expresion RPAREN .)


state 103

    (28) asignacion -> ID LBRACKET expresion RBRACKET EQUALS . expresion SEMICOLON
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 114

state 104

    (29) retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .

    RCBRACKET       reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    ID              reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    RETURN          reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    READ            reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    WRITE           reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    IF              reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    WHILE           reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    FOR             reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    $end            reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    ELSE            reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)
    LCBRACKET       reduce using rule 29 (retornofuncion -> RETURN LPAREN expresion RPAREN SEMICOLON .)


state 105

    (43) escritura2 -> RPAREN SEMICOLON .

    RCBRACKET       reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    ID              reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    RETURN          reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    READ            reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    WRITE           reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    IF              reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    WHILE           reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    FOR             reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    $end            reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    ELSE            reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)
    LCBRACKET       reduce using rule 43 (escritura2 -> RPAREN SEMICOLON .)


state 106

    (46) letrero1 -> CHAR QUOTES .

    RPAREN          reduce using rule 46 (letrero1 -> CHAR QUOTES .)
    QUOTES          reduce using rule 46 (letrero1 -> CHAR QUOTES .)
    LPAREN          reduce using rule 46 (letrero1 -> CHAR QUOTES .)
    INT             reduce using rule 46 (letrero1 -> CHAR QUOTES .)
    FLOAT           reduce using rule 46 (letrero1 -> CHAR QUOTES .)


state 107

    (47) letrero1 -> CHAR letrero1 .

    RPAREN          reduce using rule 47 (letrero1 -> CHAR letrero1 .)
    QUOTES          reduce using rule 47 (letrero1 -> CHAR letrero1 .)
    LPAREN          reduce using rule 47 (letrero1 -> CHAR letrero1 .)
    INT             reduce using rule 47 (letrero1 -> CHAR letrero1 .)
    FLOAT           reduce using rule 47 (letrero1 -> CHAR letrero1 .)


state 108

    (50) decision -> IF LPAREN expresion RPAREN THEN . bloque decision1
    (15) bloque -> . LCBRACKET estatuto bloque1
    (16) bloque -> . LCBRACKET RCBRACKET

    LCBRACKET       shift and go to state 15

    bloque                         shift and go to state 115

state 109

    (52) condicional -> WHILE LPAREN expresion RPAREN DO . bloque
    (15) bloque -> . LCBRACKET estatuto bloque1
    (16) bloque -> . LCBRACKET RCBRACKET

    LCBRACKET       shift and go to state 15

    bloque                         shift and go to state 116

state 110

    (53) nocondicional -> FOR ID EQUALS expresion TO . expresion DO bloque
    (30) expresion -> . expresion PLUS expresion
    (31) expresion -> . expresion MINUS expresion
    (32) expresion -> . expresion TIMES expresion
    (33) expresion -> . expresion DIVIDE expresion
    (34) expresion -> . LPAREN expresion RPAREN
    (35) expresion -> . INT
    (36) expresion -> . FLOAT

    LPAREN          shift and go to state 58
    INT             shift and go to state 59
    FLOAT           shift and go to state 60

    expresion                      shift and go to state 117

state 111

    (14) function -> FUNCTION tiporetorno ID LPAREN variables1 RPAREN SEMICOLON . variables bloque
    (2) variables -> . VARS variables1

    VARS            shift and go to state 6

    variables                      shift and go to state 118

state 112

    (8) listaids2 -> LBRACKET INT RBRACKET listaids1 .

    FUNCTION        reduce using rule 8 (listaids2 -> LBRACKET INT RBRACKET listaids1 .)
    LCBRACKET       reduce using rule 8 (listaids2 -> LBRACKET INT RBRACKET listaids1 .)
    RPAREN          reduce using rule 8 (listaids2 -> LBRACKET INT RBRACKET listaids1 .)
    ID              reduce using rule 8 (listaids2 -> LBRACKET INT RBRACKET listaids1 .)


state 113

    (9) listaids2 -> LBRACKET INT RBRACKET SEMICOLON .
    (7) listaids1 -> SEMICOLON .
    (10) listaids2 -> SEMICOLON .

  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for LCBRACKET resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for RPAREN resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for LCBRACKET resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for RPAREN resolved using rule 7 (listaids1 -> SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 7 (listaids1 -> SEMICOLON .)
    FUNCTION        reduce using rule 7 (listaids1 -> SEMICOLON .)
    LCBRACKET       reduce using rule 7 (listaids1 -> SEMICOLON .)
    RPAREN          reduce using rule 7 (listaids1 -> SEMICOLON .)
    ID              reduce using rule 7 (listaids1 -> SEMICOLON .)

  ! FUNCTION        [ reduce using rule 9 (listaids2 -> LBRACKET INT RBRACKET SEMICOLON .) ]
  ! LCBRACKET       [ reduce using rule 9 (listaids2 -> LBRACKET INT RBRACKET SEMICOLON .) ]
  ! RPAREN          [ reduce using rule 9 (listaids2 -> LBRACKET INT RBRACKET SEMICOLON .) ]
  ! ID              [ reduce using rule 9 (listaids2 -> LBRACKET INT RBRACKET SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]
  ! LCBRACKET       [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]
  ! RPAREN          [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]
  ! ID              [ reduce using rule 10 (listaids2 -> SEMICOLON .) ]


state 114

    (28) asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion . SEMICOLON
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    SEMICOLON       shift and go to state 119
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 115

    (50) decision -> IF LPAREN expresion RPAREN THEN bloque . decision1
    (51) decision1 -> . ELSE bloque

    ELSE            shift and go to state 121

    decision1                      shift and go to state 120

state 116

    (52) condicional -> WHILE LPAREN expresion RPAREN DO bloque .

    RCBRACKET       reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    ID              reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    RETURN          reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    READ            reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    WRITE           reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    IF              reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    WHILE           reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    FOR             reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    $end            reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    ELSE            reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)
    LCBRACKET       reduce using rule 52 (condicional -> WHILE LPAREN expresion RPAREN DO bloque .)


state 117

    (53) nocondicional -> FOR ID EQUALS expresion TO expresion . DO bloque
    (30) expresion -> expresion . PLUS expresion
    (31) expresion -> expresion . MINUS expresion
    (32) expresion -> expresion . TIMES expresion
    (33) expresion -> expresion . DIVIDE expresion

    DO              shift and go to state 122
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 118

    (14) function -> FUNCTION tiporetorno ID LPAREN variables1 RPAREN SEMICOLON variables . bloque
    (15) bloque -> . LCBRACKET estatuto bloque1
    (16) bloque -> . LCBRACKET RCBRACKET

    LCBRACKET       shift and go to state 15

    bloque                         shift and go to state 123

state 119

    (28) asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .

    RCBRACKET       reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    ID              reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    RETURN          reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    READ            reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    WRITE           reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    IF              reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    WHILE           reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    FOR             reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    $end            reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    ELSE            reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)
    LCBRACKET       reduce using rule 28 (asignacion -> ID LBRACKET expresion RBRACKET EQUALS expresion SEMICOLON .)


state 120

    (50) decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .

    RCBRACKET       reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    ID              reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    RETURN          reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    READ            reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    WRITE           reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    IF              reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    WHILE           reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    FOR             reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    $end            reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    ELSE            reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)
    LCBRACKET       reduce using rule 50 (decision -> IF LPAREN expresion RPAREN THEN bloque decision1 .)


state 121

    (51) decision1 -> ELSE . bloque
    (15) bloque -> . LCBRACKET estatuto bloque1
    (16) bloque -> . LCBRACKET RCBRACKET

    LCBRACKET       shift and go to state 15

    bloque                         shift and go to state 124

state 122

    (53) nocondicional -> FOR ID EQUALS expresion TO expresion DO . bloque
    (15) bloque -> . LCBRACKET estatuto bloque1
    (16) bloque -> . LCBRACKET RCBRACKET

    LCBRACKET       shift and go to state 15

    bloque                         shift and go to state 125

state 123

    (14) function -> FUNCTION tiporetorno ID LPAREN variables1 RPAREN SEMICOLON variables bloque .

    LCBRACKET       reduce using rule 14 (function -> FUNCTION tiporetorno ID LPAREN variables1 RPAREN SEMICOLON variables bloque .)


state 124

    (51) decision1 -> ELSE bloque .

    $end            reduce using rule 51 (decision1 -> ELSE bloque .)
    ELSE            reduce using rule 51 (decision1 -> ELSE bloque .)
    RCBRACKET       reduce using rule 51 (decision1 -> ELSE bloque .)
    ID              reduce using rule 51 (decision1 -> ELSE bloque .)
    RETURN          reduce using rule 51 (decision1 -> ELSE bloque .)
    READ            reduce using rule 51 (decision1 -> ELSE bloque .)
    WRITE           reduce using rule 51 (decision1 -> ELSE bloque .)
    IF              reduce using rule 51 (decision1 -> ELSE bloque .)
    WHILE           reduce using rule 51 (decision1 -> ELSE bloque .)
    FOR             reduce using rule 51 (decision1 -> ELSE bloque .)
    LCBRACKET       reduce using rule 51 (decision1 -> ELSE bloque .)


state 125

    (53) nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .

    RCBRACKET       reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    ID              reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    RETURN          reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    READ            reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    WRITE           reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    IF              reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    WHILE           reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    FOR             reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    $end            reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    ELSE            reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)
    LCBRACKET       reduce using rule 53 (nocondicional -> FOR ID EQUALS expresion TO expresion DO bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 55 resolved using rule (listaids1 -> SEMICOLON)
WARNING: rejected rule (listaids2 -> SEMICOLON) in state 55
WARNING: reduce/reduce conflict in state 113 resolved using rule (listaids1 -> SEMICOLON)
WARNING: rejected rule (listaids2 -> LBRACKET INT RBRACKET SEMICOLON) in state 113
WARNING: reduce/reduce conflict in state 113 resolved using rule (listaids1 -> SEMICOLON)
WARNING: rejected rule (listaids2 -> SEMICOLON) in state 113
WARNING: Rule (listaids2 -> SEMICOLON) is never reduced
WARNING: Rule (listaids2 -> LBRACKET INT RBRACKET SEMICOLON) is never reduced
